import { parseAbi } from 'viem';
class TransactionError extends Error {
    receipt;
    name = 'TransactionError';
    constructor(receipt) {
        super('Transaction reverted');
        this.receipt = receipt;
    }
}
export async function* wrapTransaction(title, ctx, { contract, data: data_, value: value_, messages, }) {
    const data = Array.isArray(data_) ? data_ : [data_];
    if (ctx.isBatching) {
        yield {
            contract,
            data,
            value: value_,
            messages,
        };
    }
    else {
        const messagesEstimates = messages
            ? await Promise.all(Object.entries(messages).map(async ([centId, messageTypes]) => ctx.root._estimate(ctx.chainId, { centId: Number(centId) }, messageTypes)))
            : [];
        const estimate = messagesEstimates.reduce((acc, val) => acc + val, 0n);
        const value = (value_ ?? 0n) + estimate;
        const result = yield* doTransaction(title, ctx.publicClient, async () => {
            if (data.length === 1) {
                return ctx.walletClient.sendTransaction({
                    to: contract,
                    data: data[0],
                    value,
                });
            }
            return ctx.walletClient.writeContract({
                address: contract,
                abi: parseAbi(['function multicall(bytes[] data) payable']),
                functionName: 'multicall',
                args: [data],
                value,
            });
        });
        return result;
    }
}
export async function* doTransaction(title, publicClient, transactionCallback) {
    const id = Math.random().toString(36).substring(2);
    yield { id, type: 'SigningTransaction', title };
    const hash = await transactionCallback();
    yield { id, type: 'TransactionPending', title, hash };
    const receipt = await publicClient.waitForTransactionReceipt({ hash });
    if (receipt.status === 'reverted') {
        console.error('Transaction reverted', receipt);
        throw new TransactionError(receipt);
    }
    const result = { id, type: 'TransactionConfirmed', title, hash, receipt };
    yield result;
    return result;
}
export async function* doSignMessage(title, transactionCallback) {
    const id = Math.random().toString(36).substring(2);
    yield { id, type: 'SigningMessage', title };
    const message = await transactionCallback();
    yield { id, type: 'SignedMessage', title, signed: message };
    return message;
}
export function isLocalAccount(signer) {
    return 'type' in signer && signer.type === 'local';
}
//# sourceMappingURL=transaction.js.map