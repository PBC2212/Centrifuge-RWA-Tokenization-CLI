import { encodeFunctionData, encodePacked, keccak256, parseAbiItem, toFunctionSelector, toHex } from 'viem';
import { ABI } from '../abi/index.js';
import { MessageType } from '../types/transaction.js';
import { BigIntWrapper } from '../utils/BigInt.js';
import { addressToBytes32 } from '../utils/index.js';
import { wrapTransaction } from '../utils/transaction.js';
import { Entity } from './Entity.js';
/**
 * Query and interact with a Merkle Proof Manager.
 */
export class MerkleProofManager extends Entity {
    network;
    pool;
    chainId;
    /**
     * The contract address of the Merkle Proof Manager.
     */
    address;
    /** @internal */
    constructor(_root, network, address) {
        super(_root, ['merkleProofManager', network.chainId, network.pool.id.toString()]);
        this.network = network;
        this.chainId = network.chainId;
        this.pool = network.pool;
        this.address = address.toLowerCase();
    }
    async getPolicyRoot() {
        const { SimpleMerkleTree } = await import('@openzeppelin/merkle-tree');
        const poolId = 281474976710657n;
        const scId = '0x31000000000000000000000000000000';
        const erc20 = '0xa0Cb889707d426A7A386870A03bc70d1b0697598';
        const manager = '0xA4AD4f68d0b91CFD19687c881e50f3A00242828c';
        const leaves = [
            {
                decoder: '0x03A6a84cD762D9707A21605b548aaaB891562aAb',
                target: '0x1B237b1866D34C8619D52F9A5047a4Ab976e0426',
                valueNonZero: false,
                selector: toFunctionSelector('function withdraw(uint64,bytes16,address,uint256,address,uint128)'),
                addresses: encodePacked(['uint64', 'bytes16', 'address', 'address'], [poolId, scId, erc20, manager]),
            },
            {
                decoder: '0x03A6a84cD762D9707A21605b548aaaB891562aAb',
                target: '0x1B237b1866D34C8619D52F9A5047a4Ab976e0426',
                valueNonZero: false,
                selector: toFunctionSelector('function deposit(uint64,bytes16,address,uint256,uint128)'),
                addresses: encodePacked(['uint64', 'bytes16', 'address'], [poolId, scId, erc20]),
            },
        ];
        console.log('withdrawsel', toFunctionSelector('function withdraw(uint64,bytes16,address,uint256,address,uint128)'));
        console.log('addr', encodePacked(['uint64', 'bytes16', 'address', 'address'], [poolId, scId, erc20, manager]));
        console.log('0x000100000000000131000000000000000000000000000000a0cb889707d426a7a386870a03bc70d1b0697598a4ad4f68d0b91cfd19687c881e50f3a00242828c' ===
            encodePacked(['uint64', 'bytes16', 'address', 'address'], [poolId, scId, erc20, manager]));
        console.log('depositsel', toFunctionSelector('function deposit(uint64,bytes16,address,uint256,uint128)'));
        console.log('addr', encodePacked(['uint64', 'bytes16', 'address'], [poolId, scId, erc20]));
        const leavesHashes = leaves.map((leaf) => keccak256(encodePacked(['address', 'address', 'bool', 'bytes4', 'bytes'], [leaf.decoder, leaf.target, leaf.valueNonZero, leaf.selector, leaf.addresses])));
        const tree = SimpleMerkleTree.of(leavesHashes);
        console.log('tree', tree, tree.root);
    }
    setPolicies(strategist, policies, actions = []) {
        const self = this;
        return this._transact(async function* (ctx) {
            const [{ hub }, id, poolDetails] = await Promise.all([
                self._root._protocolAddresses(self.pool.chainId),
                self._root.id(self.chainId),
                self.pool.details(),
            ]);
            const rootHash = toHex(0, { size: 32 });
            yield* wrapTransaction('Set policies', ctx, {
                contract: hub,
                data: encodeFunctionData({
                    abi: ABI.Hub,
                    functionName: 'updateContract',
                    args: [
                        self.pool.id.raw,
                        toHex(0, { size: 16 }),
                        id,
                        addressToBytes32(self.address),
                        encodePacked(['uint8', 'bytes32', 'bytes32'], [/* UpdateContractType.Policy */ 4, addressToBytes32(strategist), rootHash]),
                        0n,
                    ],
                }),
                messages: { [id]: [MessageType.UpdateContract] },
            });
        }, this.pool.chainId);
    }
    /**
     * Disable strategist.
     * @param strategist - The strategist address to disable
     */
    disableStrategist(strategist) {
        return this.setPolicies(strategist, []);
    }
    execute(calls) {
        const self = this;
        return this._transact(async function* (ctx) {
            const [{ hub }, id, poolDetails] = await Promise.all([
                self._root._protocolAddresses(self.pool.chainId),
                self._root.id(self.chainId),
                self.pool.details(),
            ]);
            const addressesEncoded = await Promise.all(calls.map(async (call) => {
                const { policy, values } = call;
                const abi = parseAbiItem(policy.abi);
                const args = [...policy.addresses];
                values.forEach((value, i) => {
                    const argIndex = policy.inputs[i];
                    args[argIndex] = value instanceof BigIntWrapper ? value.toBigInt() : value;
                });
                const dataObj = {
                    abi: [abi],
                    functionName: abi.name,
                    args,
                };
                const data = encodeFunctionData(dataObj);
                const result = await ctx.publicClient.readContract({
                    address: policy.decoder,
                    data,
                });
                const encoded = encodePacked(['address', 'address', 'bool', 'bytes4', 'bytes'], [
                    policy.decoder,
                    policy.target,
                    policy.valueNonZero,
                    toFunctionSelector(policy.abi),
                    encodePacked(policy.inputs.map((input, i) => {
                        if (input.type === 'address') {
                            return values[i];
                        }
                        else if (input.type === 'uint') {
                            return BigInt(values[i]);
                        }
                        throw new Error(`Unsupported input type: ${input.type}`);
                    })),
                ]);
                return encoded;
            }));
            const leavesHashes = calls.map((leaf) => keccak256(encodePacked(['address', 'address', 'bool', 'bytes4', 'bytes'], [leaf.decoder, leaf.target, leaf.valueNonZero, leaf.selector, leaf.addresses])));
        }, this.chainId);
    }
}
//# sourceMappingURL=MerkleProofManager.js.map