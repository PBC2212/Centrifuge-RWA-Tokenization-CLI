import { combineLatest, map } from 'rxjs';
import { Entity } from '../Entity.js';
import { IndexerQueries } from '../IndexerQueries/index.js';
import { processor } from './Processor.js';
const DEFAULT_FILTER = {
    from: '2024-01-01T00:00:00.000Z',
    to: new Date().toISOString(),
};
export class Reports extends Entity {
    pool;
    queries;
    /** @internal */
    constructor(centrifuge, pool) {
        super(centrifuge, ['reports', pool.id.toString()]);
        this.pool = pool;
        this.queries = new IndexerQueries(centrifuge, pool);
    }
    balanceSheet(filter) {
        return this._generateReport('balanceSheet', filter);
    }
    cashflow(filter) {
        return this._generateReport('cashflow', filter);
    }
    profitAndLoss(filter) {
        return this._generateReport('profitAndLoss', filter);
    }
    investorTransactions(filter) {
        return this._generateReport('investorTransactions', filter);
    }
    assetTransactions(filter) {
        return this._generateReport('assetTransactions', filter);
    }
    tokenPrice(filter) {
        return this._generateReport('tokenPrice', filter);
    }
    feeTransactions(filter) {
        return this._generateReport('feeTransactions', filter);
    }
    assetList(filter) {
        return this._generateReport('assetList', filter);
    }
    investorList(filter) {
        return this._generateReport('investorList', filter);
    }
    ordersList(filter) {
        return this._generateReport('ordersList', filter);
    }
    assetTimeSeries(filter) {
        return this._generateReport('assetTimeSeries', filter);
    }
    _generateReport(type, filter) {
        return this._query([
            type,
            filter?.from,
            filter?.to,
            filter?.groupBy,
            filter?.address,
            filter?.network,
            filter?.tokenId,
            filter?.transactionType,
            filter?.assetId,
            filter?.status,
            filter?.name,
        ], () => {
            const { from, to, ...restFilter } = filter ?? {};
            const dateFilter = {
                timestamp: {
                    greaterThan: from ?? DEFAULT_FILTER.from,
                    lessThanOrEqualTo: (to && `${to.split('T')[0]}T23:59:59.999Z`) ?? DEFAULT_FILTER.to,
                },
            };
            const metadata$ = this.pool.metadata();
            const poolSnapshots$ = this.queries.poolSnapshotsQuery({
                ...dateFilter,
                poolId: { equalTo: this.pool.id },
            });
            const trancheSnapshots$ = this.queries.trancheSnapshotsQuery({
                ...dateFilter,
                tranche: { poolId: { equalTo: this.pool.id } },
            });
            const poolFeeSnapshots$ = this.queries.poolFeeSnapshotsQuery({
                ...dateFilter,
                poolFeeId: { includes: this.pool.id },
            });
            const investorTransactions$ = this.queries.investorTransactionsQuery({
                ...dateFilter,
                poolId: { equalTo: this.pool.id },
            });
            const assetTransactions$ = this.queries.assetTransactionsQuery({
                ...dateFilter,
                poolId: { equalTo: this.pool.id },
            });
            const poolFeeTransactions$ = this.queries.poolFeeTransactionsQuery({
                ...dateFilter,
                poolFee: { poolId: { equalTo: this.pool.id } },
            });
            const assetSnapshots$ = this.queries.assetSnapshotsQuery({
                ...dateFilter,
                asset: { poolId: { equalTo: this.pool.id } },
            });
            const trancheCurrencyBalance$ = this.queries.trancheCurrencyBalanceQuery({
                pool: { id: { equalTo: this.pool.id } },
            }, {
                currency: { pool: { id: { equalTo: this.pool.id } } },
            });
            const poolEpochs$ = this.queries.poolEpochsQuery({
                closedAt: {
                    ...(from && { greaterThan: from }),
                    lessThanOrEqualTo: (to && `${to.split('T')[0]}T23:59:59.999Z`) ?? DEFAULT_FILTER.to,
                },
                pool: { id: { equalTo: this.pool.id } },
            });
            switch (type) {
                case 'balanceSheet':
                    return combineLatest([poolSnapshots$, trancheSnapshots$]).pipe(map(([poolSnapshots, trancheSnapshots]) => processor.balanceSheet({ poolSnapshots, trancheSnapshots }, restFilter)));
                case 'cashflow':
                    return combineLatest([poolSnapshots$, poolFeeSnapshots$, metadata$]).pipe(map(([poolSnapshots, poolFeeSnapshots, metadata]) => processor.cashflow({ poolSnapshots, poolFeeSnapshots, metadata }, restFilter)));
                case 'profitAndLoss':
                    return combineLatest([poolSnapshots$, poolFeeSnapshots$, metadata$]).pipe(map(([poolSnapshots, poolFeeSnapshots, metadata]) => processor.profitAndLoss({ poolSnapshots, poolFeeSnapshots, metadata }, restFilter)));
                case 'investorTransactions':
                    return combineLatest([investorTransactions$]).pipe(map(([investorTransactions]) => processor.investorTransactions({ investorTransactions }, restFilter)));
                case 'assetTransactions':
                    return combineLatest([assetTransactions$]).pipe(map(([assetTransactions]) => processor.assetTransactions({ assetTransactions }, restFilter)));
                case 'feeTransactions':
                    return combineLatest([poolFeeTransactions$]).pipe(map(([poolFeeTransactions]) => processor.feeTransactions({ poolFeeTransactions }, restFilter)));
                case 'tokenPrice':
                    return combineLatest([trancheSnapshots$]).pipe(map(([trancheSnapshots]) => processor.tokenPrice({ trancheSnapshots }, restFilter)));
                case 'assetList':
                    return combineLatest([assetSnapshots$, metadata$]).pipe(map(([assetSnapshots, metadata]) => processor.assetList({ assetSnapshots, metadata }, restFilter)));
                case 'investorList':
                    return combineLatest([trancheCurrencyBalance$]).pipe(map(([trancheCurrencyBalance]) => processor.investorList({ trancheCurrencyBalance }, restFilter)));
                case 'ordersList':
                    return combineLatest([poolEpochs$]).pipe(map(([poolEpochs]) => processor.ordersList({ poolEpochs })));
                case 'assetTimeSeries':
                    return combineLatest([assetSnapshots$]).pipe(map(([assetSnapshots]) => processor.assetTimeSeries({ assetSnapshots }, restFilter)));
                default:
                    throw new Error(`Unsupported report type: ${type}`);
            }
        }, {
            valueCacheTime: 120_000,
        });
    }
}
//# sourceMappingURL=index.js.map